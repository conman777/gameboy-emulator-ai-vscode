/// <reference types="node" />
import CPU from "./CPU";
import ROM from "./ROM";
import LCD from "./LCD";
import Joypad from "./Joypad";
import Actions from "./actions";
import Memory from "./memory/Memory";
import { EventEmitter } from "events";
import Storage from "./storages/Storage";
import StateManager from "./StateManager";
import AudioDevice from "./audio/AudioDevice";
import Cartridge from "./cartridge/Cartridge";
import GPU from "./GPU";
import AudioController from "./audio/AudioController";
import { Debounced } from "./util";
export declare type Action = ("Start" | "Select" | "A" | "B" | "Up" | "Down" | "Left" | "Right");
export declare const actions: Action[];
export default class GameBoy extends EventEmitter {
    interval: number;
    debouncedAutoSave: Debounced;
    core: GameBoy;
    isOn: boolean;
    actions: Actions;
    storage: Storage;
    cartridge: Cartridge;
    lastRun: number;
    midScanlineOffset: number;
    currentX: number;
    stopEmulator: number;
    matchedIrqLines: number;
    ROMBank1Offset: number;
    haltPostClocks: number;
    spriteCount: number;
    BGCHRCurrentBank: Uint8Array;
    tileCache: any;
    colors: number[];
    OBJPalette: Int32Array;
    backgroundPalette: Int32Array;
    updateGBBGPalette: (data: any) => void;
    updateGBOBJPalette: (index: any, data: any) => void;
    pixelStart: number;
    pixelEnd: number;
    memory: Uint8Array;
    isBootingRom: boolean;
    videoRam: Uint8Array;
    gbcMemory: Uint8Array;
    frameBuffer: Int32Array;
    BGCHRBank1: Uint8Array;
    registerA: number;
    registerB: number;
    registerC: number;
    registerD: number;
    registerE: number;
    FZero: boolean;
    FSubtract: boolean;
    FHalfCarry: boolean;
    FCarry: boolean;
    registersHL: number;
    programCounter: number;
    stackPointer: number;
    IME: boolean;
    interruptRequestedFlags: number;
    interruptEnabledFlags: number;
    hdmaRunning: boolean;
    currentInstructionCycleCount: number;
    STATTracker: number;
    modeSTAT: number;
    LYCMatchTriggerSTAT: boolean;
    mode2TriggerSTAT: boolean;
    mode1TriggerSTAT: boolean;
    mode0TriggerSTAT: boolean;
    DIVTicks: number;
    LCDTicks: number;
    timerTicks: number;
    TIMAEnabled: boolean;
    TACClocker: number;
    serialTimer: number;
    serialShiftTimer: number;
    serialShiftTimerAllocated: number;
    IRQEnableDelay: number;
    actualScanline: number;
    lastUnrenderedLine: number;
    gfxWindowDisplay: boolean;
    gfxSpriteShow: boolean;
    gfxSpriteNormalHeight: boolean;
    backgroundEnabled: boolean;
    hasBackgroundPriority: boolean;
    gfxWindowCHRBankPosition: number;
    gfxBackgroundCHRBankPosition: number;
    gfxBackgroundBankOffset: number;
    windowY: number;
    windowX: number;
    drewBlank: number;
    halt: boolean;
    skipPCIncrement: boolean;
    doubleSpeedShifter: number;
    colorizedGBPalettes: boolean;
    backgroundX: number;
    gbcOBJRawPalette: Uint8Array;
    gbcBGRawPalette: Uint8Array;
    gbcOBJPalette: Int32Array;
    gbcBGPalette: Int32Array;
    BGCHRBank2: Uint8Array;
    currentVideoRamBank: number;
    gbOBJPalette: Int32Array;
    gbBGPalette: Int32Array;
    sortBuffer: Uint8Array;
    OAMAddressCache: Int32Array;
    gbBGColorizedPalette: Int32Array;
    gbOBJColorizedPalette: Int32Array;
    cachedBGPaletteConversion: Int32Array;
    cachedOBJPaletteConversion: Int32Array;
    backgroundY: number;
    queuedScanlines: number;
    remainingClocks: number;
    gbcRamBankPosition: number;
    gbcEchoRamBankPosition: number;
    gbcRamBank: number;
    stateManager: StateManager;
    lcdDevice: LCD;
    joypad: Joypad;
    audioController: AudioController;
    audioDevice: AudioDevice;
    cpu: CPU;
    gpu: GPU;
    memoryNew: Memory;
    usedBootRom: boolean;
    gbBootRom?: ROM;
    gbcBootRom?: ROM;
    usedGbcBootRom: boolean;
    memoryReader: any[];
    memoryWriter: any[];
    highMemoryReader: any[];
    highMemoryWriter: any[];
    constructor(options?: {
        audio?: any;
        lcd?: any;
        bootRom?: ArrayBuffer;
    });
    isPaused(): boolean;
    setStorage(storage: Storage): void;
    registerActions(): void;
    handleSpeed(options: any): void;
    turnOn(): void;
    frameHandler: (now: number) => void;
    turnOff(): void;
    restart(): void;
    setGbBootRom(rom: ROM | ArrayBuffer | Uint8Array): void;
    setGbcBootRom(rom: ROM | ArrayBuffer | Uint8Array): void;
    replaceCartridge(cartridge: Cartridge | ArrayBuffer | Uint8Array): void;
    removeCartridge(): void;
    insertCartridge(cartridge: Cartridge | ArrayBuffer | Uint8Array): void;
    actionDown(action: Action, options?: any): void;
    actionChange(action: Action, options: any): void;
    actionUp(action: Action, options?: any): void;
    autoSave(): void;
    saveState(state: any): Promise<boolean>;
    saveRam(ram?: any): Promise<boolean>;
    saveRtc(rtc?: any): Promise<boolean>;
    loadState(state: any): boolean;
    loadRam(ram?: any): boolean;
    loadRtc(rtc?: any): boolean;
    getBatteryFileArrayBuffer(): ArrayBuffer;
    loadBatteryFileArrayBuffer(data: ArrayBuffer): Promise<void>;
    requestFrame(fn: (now: number) => void): void;
    connectCartridge(cartridge: Cartridge): void;
    rumble(): void;
    onMbcRamWrite: () => void;
    loadGbcBootRomIntoMemory(): void;
    loadGbBootRomIntoMemory(): void;
    loadCartridgeRomIntoMemory(): void;
    start(cartridge: Cartridge): void;
    generateCacheArray(tileAmount: number): any[];
    skipBootRom(): void;
    initBootRom(): void;
    disableBootRom(): void;
    setSpeed(speed: number): void;
    run(): void;
    executeIteration(): void;
    iterationEndRoutine(): void;
    stop(): void;
    recalculateIterationClockLimit(): void;
    scanLineMode2(): void;
    scanLineMode3(): void;
    scanLineMode0(): void;
    clocksUntilLYCMatch(): number;
    clocksUntilMode0(): number;
    updateSpriteCount(line: number): void;
    matchLYC(): void;
    updateCore(): void;
    updateCoreFull(): void;
    executeHDMA(): void;
    renderScanline(scanline: number): void;
    renderMidScanline(): void;
    adjustGbctoGbMode(): void;
    initReferencesFromSaveState(): void;
    adjustRGBTint(value: number): number;
    getGBCColor(): void;
    updateGBRegularBGPalette(data: number): void;
    updateGBColorizedBGPalette(data: number): void;
    updateGBRegularOBJPalette(address: number, data: number): void;
    updateGBColorizedOBJPalette(address: number, data: number): void;
    updateGBCBGPalette(address: number, data: number): void;
    updateGBCOBJPalette(address: number, data: number): void;
    findLowestSpriteDrawable(scanline: number, drawableRange: number): number;
    generateGBTileLine(address: number): void;
    generateGBCTileLineBank1(address: number): void;
    generateGBCTileBank1(vramAddress: any): void;
    generateGBCTileLineBank2(address: number): void;
    generateGBCTileBank2(vramAddress: any): void;
    generateGBOAMTileLine(address: number): void;
    graphicsJIT(): void;
    graphicsJITVBlank(): void;
    renderQueuedScanlines(): void;
    incrementScanlineQueue(): void;
    midScanlineJIT(): void;
    launchIRQ(): void;
    checkIrqMatching(): void;
    calculateHALTPeriod(): void;
    readMemory: (address: number) => any;
    memoryHighRead(address: number): any;
    writeMemory(address: number, data: number): any;
    memoryHighWrite(address: number, data: number): any;
    memoryHighReadNormal: (address: number) => number;
    memoryReadGBCMemory: (address: number) => number;
    memoryReadOAM: (address: number) => number;
    readGbcEchoRam: (address: number) => number;
    readEchoRam: (address: number) => number;
    readGbcVideoRam: (address: number) => number;
    readVideoRam: (address: number) => number;
    readGbcCharacterVideoRam: (address: number) => number;
    readCharacterVideoRam: (address: number) => number;
    memoryWriteNormal: (address: number, data: number) => void;
    memoryHighWriteNormal: (address: number, data: number) => void;
    memoryWriteGBCRAM: (address: number, data: number) => void;
    memoryWriteOAMRAM(address: number, data: number): void;
    memoryWriteECHOGBCRAM(address: number, data: number): void;
    memoryWriteECHONormal: (address: number, data: number) => void;
    VRAMGBDATAWrite(address: number, data: number): void;
    VRAMGBDATAUpperWrite(address: number, data: number): void;
    VRAMGBCDATAWrite(address: number, data: number): void;
    VRAMGBCHRMAPWrite(address: number, data: number): void;
    VRAMGBCCHRMAPWrite(address: number, data: number): void;
    writeDirectlyToMemory(tilesToTransfer: number): void;
}
